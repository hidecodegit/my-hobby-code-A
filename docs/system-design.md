# システム設計 (System Design)

本ドキュメントは、PiPulseパイプラインの全体フロー設計、データフロー、およびシステム設計に関する改善事例を記録します。構成管理（タイムゾーン方針、リスク対策）もここに統合し、一元管理を強化。

**最終更新:** 2025-10-31

### 改訂履歴
| 日付 | 変更者 | 変更内容 | 関連 |
|---|---|---|---|
|2025-10-31|Hideo (assisted by Gemini/Grok)|INC-005（データ形式混在）を追加し、その原因にトレーサビリティ不足の教訓を追記。リスク対策テーブルも更新。| - |
|2025-10-27|Hideo (assisted by Gemini/Grok)|INC-01追加で事例連番化。config-management.mdの内容を統合（タイムゾーン方針/リスク対策を予防策にマージ）。データフロー図をMermaidで追加し、v-master-guideline.mdと整合。INC-002の解決策にビフォーアフター図を追加で可視化。SYS.2ルールの文言を簡略化。|PR #20 (統合マージ)|
|2025-10-22|Hideo (assisted by Gemini)|初版作成。タイムゾーン移行ミスマッチの事例を記録。| - |

---

### 構成管理 (タイムゾーン方針と潜在リスク)

#### タイムゾーン方針
#### タイムゾーン方針 (JST統一)
全てのタイムスタンプは **JST（日本標準時）** で記録・処理します。これは、個人の趣味プロジェクトとしてのシンプルさと直感的な分かりやすさを最優先するための方針です。
- Raspberry Piのシステム時刻がJSTに設定されていることを前提とします。
- **将来的な注意点**: 海外のクラウドサービス連携や複数地域への展開時には、UTCに統一する再設計が必要になる可能性があります。
- **移行注意**: タイムゾーン移行時は既存データとの整合性チェックが必須です（詳細は `INC-002` を参照）。

#### 潜在リスクと対策
| リスク内容 | 対策 | 関連事例 |
|---|---|---|
| **I2C/センサーエラー** | エラーカウンタとセンサー再初期化を実装。I2Cバスを明示的にクローズ。 | - |
| **メモリ不足 (RPi)** | RAMディスク (`/tmp/sensor_data`) を使用し、SDカードへの書き込みを抑制。 | - |
| **データ同期エラー** | `rclone` 実行時にリトライ処理（指数バックオフ）を実装。 | - |
| **データ損失** | `rclone sync` の代わりに `rclone copy` を採用。 | `INC-01` |
| **運用ログ不足** | 全体同期の実行理由をログに出力し、運用の透明性を確保。 | - |
| **状態更新エラー** | `try-except` でファイル書き込み処理を堅牢化。 | `INC-003` (`qa-plan.md`参照) |
| **データ形式の不整合** | 柔軟なパース関数を実装し、後方互換性を維持。 | `INC-005` |

---

## 設計改善事例

### INC-01: rclone Sync誤用によるデータ損失（2025-10-20）

#### 概要
`rclone`の`sync`コマンド使用時に、誤ってローカルデータを上書き削除するインシデントが発生しました。

#### 解決策と予防策
- **解決策**: `copy`コマンドに切り替え（v1.3.0で採用）。`--dry-run`オプションをテスト時に必須化。
- **予防策**: コマンド実行前にシミュレーションをルール化（SYS.2適用）。

### INC-002: タイムゾーン移行ミスマッチ（UTC→JST, 2025-10-22）

### 概要
PiPulseパイプラインのタイムゾーン方針をUTCからJSTに統一する移行作業において、過去のUTCで記録されたJSONデータとの互換性問題が発生し、データ同期処理がサイレントに失敗する事象が発生しました。

### 原因
システム設計段階で、タイムゾーン方針の変更に伴う既存データの互換性（特にISOフォーマットのタイムスタンプに付加されたタイムゾーン情報）に関する考慮が不十分でした。古いUTCのJSONデータが、JST統一後の処理で予期せぬ `TypeError` を引き起こしました。

### 影響
一部のデータ同期処理が停止し、最新のデータがGoogle Driveにアップロードされない期間が発生しました。

### 解決策と予防策
- **解決策**: 過去のUTCで記録されたJSONファイルを削除し、タイムゾーン情報を持たないISOフォーマットの文字列として保存するようにコードを修正しました。また、タイムゾーン情報を剥ぎ取る処理を追加しました。
- **予防策**:
    - **SYS.2ルール**: 今後、システム全体に関わる設定（特にデータ形式やタイムゾーン）を変更する際は、既存データとの整合性を検証することを必須とします。
    - **データフロー図の活用**: データフロー図に「移行ステップ」のような変換処理を明示し、設計段階で互換性問題を可視化します。
      ```mermaid
      graph LR
          Sensor[センサーデータ取得] --> JSON["JSON保存 (ISOタイムスタンプ without TZ)"]
          JSON --> Cleanup[移行ステップ: UTCクリーンアップ]
          Cleanup --> Sync["データ同期 (JST統一, <1min目標)"]
          Sync --> Drive[Google Driveアップロード]
      ```
    - **API/ライブラリの選定**: `datetime.fromisoformat()` のようなタイムゾーンハンドリングが厳密なAPIを使用する際は、その挙動を十分に理解し、テストケースに含めるようにします。
      ```python
      # 予防策を検証するテストケースのサンプル
      import datetime
      
      # タイムゾーン情報を持つISO文字列
      ts_with_tz = "2025-10-27T10:00:00+00:00"
      
      # 解決策: タイムゾーン情報を剥ぎ取る処理
      dt_object = datetime.datetime.fromisoformat(ts_with_tz)
      dt_stripped = dt_object.replace(tzinfo=None)
      assert dt_stripped.isoformat() == "2025-10-27T10:00:00"      

### INC-005: データ形式進化による秒有無混在（2025-10-19移行時）

#### 概要
センサー出力スクリプトの微調整（精度向上のため秒追加）により、Google Driveの蓄積データに秒なし（初期: `%Y-%m-%d %H:%M`）と秒あり（以降: `%Y-%m-%d %H:%M:%S`）が混在。`REQ-03`のMySQL取り込みでパースエラーのリスクが発生しました。

#### 原因
7月データ（秒なし、192件ベースライン）でのE2Eテスト・検証が不十分でした。初期要件定義（`SYS.1`）で形式をISO指定したものの、運用中のセンサー出力変更時の互換性チェックを怠りました。`V&V.1`（ユニットテスト）のカバレッジがデータ形式のバリエーションをカバーしきれていませんでした。
加えて、マスターガイドラインの用語集（7月データ秒なし形式）と要件定義（REQ-01.1）のトレーサビリティチェックが不十分で、形式の曖昧さが設計段階まで波及しました。

#### 影響
Driveデータの混在により、`REQ-03`のインポートスクリプトが部分的に失敗する可能性がありました（例: `datetime.strptime`エラー）。これにより、データ可視化の信頼性が低下するリスクがありました。

#### 解決策と予防策
- **暫定解決策**: `REQ-03`のMySQL取り込みスクリプトに、秒の有無を自動的に処理する柔軟なパース関数を実装しました。
  ```python
  # REQ-03拡張: 柔軟なタイムスタンプパース関数
  from datetime import datetime

  def parse_flexible_timestamp(ts_str: str) -> datetime:
      """秒の有無に関わらずタイムスタンプ文字列をパースする"""
      supported_formats = ['%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M']
      for fmt in supported_formats:
          try:
              return datetime.strptime(ts_str, fmt)
          except ValueError:
              pass
      raise ValueError(f"Timestamp '{ts_str}' does not match any supported format.")

  # 使用例:
  # parsed = parse_flexible_timestamp("2025-07-28 06:36") -> datetime.datetime(2025, 7, 28, 6, 36)
  ```

- **予防策**:
  - **SYS.2/V&V.1ルール**: データ形式を変更する際は、必ず既存のベースラインデータ（例: 7月データ）との後方互換性を検証するテストケースを追加します。**テスト不足は再発禁止** 💢。
  - **トレーサビリティ強化**: `requirements.md`の`REQ-01.1`に「7月データ（秒なし形式）でのテスト必須」を追記し、要件とテストの結びつきを強化します。
  - **データフローの可視化**: 移行ステップに形式互換性の考慮を明示します。
    ```mermaid
    graph LR
        Sensor[センサーデータ取得] --> Format["形式進化: 秒なし→あり (混在)"]
        Format --> Parse[REQ-03 パース: 柔軟なstrptime + 秒補完]
        Parse --> MySQL[MySQL挿入 (統一ISO形式)]
    ```
      ```

*この調整により、システム設計の堅牢性が向上し、[REQ-02]で求められるデータ同期の正確性を保証します。*